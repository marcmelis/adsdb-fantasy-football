# packages
import pandas as pd
import duckdb 
import math
import os
from . import duck_db_helper


def euclidean_distance(lat1, lon1, lat2, lon2):
    # Assuming the Britain can be approximated as a flat plane, calculate the distance using Pythagoras' theorem
    lat_diff = lat2 - lat1
    lon_diff = lon2 - lon1
    distance = math.sqrt(lat_diff**2 + lon_diff**2)

    return distance

def move_to_exploitation_zone(data_dir):

    trusted_zone_db = os.path.join(data_dir, 'trusted_zone', 'trusted_zone.db')
    exploitation_zone_db = os.path.join(data_dir, 'exploitation_zone', 'exploitation_zone.db')

        
    conn = duckdb.connect(trusted_zone_db)
    stadiums_df = duck_db_helper.get_table_df('team_stadium_location',conn)
    wstations_df = duck_db_helper.get_table_df('weather_station_locations',conn)

    conn.close()


    closest_stations = []

    # Loop through each team
    for i, team_row in stadiums_df.iterrows():
        min_distance = float('inf')
        closest_station = None

        # Loop through each weather station
        for j, weather_row in wstations_df.iterrows():        
            distance = euclidean_distance(team_row['LAT'], team_row['LON'], weather_row['LAT'], weather_row['LON'])
            if distance < min_distance:
                min_distance = distance
                closest_station = weather_row['SITE']
            
        closest_stations.append(closest_station)
        
    stadiums_df['closest_weather_station'] = closest_stations

    team_station_df = stadiums_df[['team_name', 'closest_weather_station']]

    conn = duckdb.connect(trusted_zone_db)
    met_df = duck_db_helper.get_table_df('Metoffice', conn)
    football_matches_df = duck_db_helper.get_table_df('football-data', conn)
    conn.close()


    football_matches_stations_df = football_matches_df.merge(team_station_df, 
                                                left_on='HomeTeam', 
                                                right_on='team_name', 
                                                how='left')

    final_football_df = football_matches_stations_df.merge(met_df, 
                                            left_on=['Date', 'closest_weather_station'], 
                                            right_on=['Date', 'Station_name'],
                                                how='left')
    # Drop the repeated columns
    final_football_df = final_football_df.drop('team_name', axis=1)
    final_football_df = final_football_df.drop('closest_weather_station', axis=1)
    final_football_df = final_football_df.drop('Station_no', axis=1)
    final_football_df = final_football_df.drop('Station_name', axis=1)


    conn = duckdb.connect(trusted_zone_db)
    players_info_df = duck_db_helper.get_table_df('cleaned_merged_seasons', conn)
    conn.close()

    for i, row in players_info_df.iterrows():
        was_home = row.was_home
        home_team = row.team_x if was_home else row.opp_team_name
        away_team = row.opp_team_name if was_home else row.team_x
        kickoff = row.kickoff_time.date()
        # Query final_football_df for a matching game
        match = final_football_df[
            (final_football_df['HomeTeam'] == home_team) &
            (final_football_df['AwayTeam'] == away_team) &
            (final_football_df['Date'].dt.date == kickoff)
        ]

        # Check if a match was found and the goals match
        if not match.empty:
            if match.iloc[0]['FTHG'] != row.team_h_score and \
                match.iloc[0]['FTAG'] != row.team_a_score:
                    print(f"Match statistics do not match between datasets for {home_team} vs {away_team} on {kickoff}")
            # If there's a match, update the date column in players_info_df
            players_info_df.at[i, 'match_date'] = kickoff

    conn = duckdb.connect(exploitation_zone_db)
    c = list(players_info_df.columns )
    c = [c[-1]] + [c[3]] + [c[18]] + [c[-4]] + c[1:3] + c[4:17] + c[19:22] + [c[-3]] + c[22:26] + c[28:34] 
    duck_db_helper.create_table('football_matches', final_football_df, conn)
    duck_db_helper.create_table('players', players_info_df[c], conn)
    conn.close()


